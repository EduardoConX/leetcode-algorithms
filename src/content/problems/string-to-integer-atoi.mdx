---
number: 8
title: "String to Integer (atoi)"
difficulty: "Medium"
categories: ["String", "Parsing", "Implementation"]
---

# Problem #8 - String to Integer (atoi)

## Problem Summary
Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer.

Rules:
1. Ignore leading whitespace.  
2. Check for an optional `'+'` or `'-'` sign.  
3. Read digits until a non-digit character is found.  
4. Ignore remaining characters after the number.  
5. Clamp the integer to the 32-bit signed range:  
   - If it’s less than `-2³¹`, return `-2³¹`.  
   - If it’s greater than `2³¹ - 1`, return `2³¹ - 1`.

Example:  
~~~text
Input: "42"  
Output: 42  

Input: "   -42"  
Output: -42  

Input: "4193 with words"  
Output: 4193  

Input: "words and 987"  
Output: 0  

Input: "-91283472332"  
Output: -2147483648  // clamped to INT_MIN
~~~

---

## Approach 1: Iterative Parsing

### Algorithm
1. Initialize `index = 0`, `sign = 1`, and `result = 0`.  
2. Skip leading spaces.  
3. Check for a `'+'` or `'-'` sign.  
4. Iterate through the digits:  
   - Convert the current character to its numeric value.  
   - Check for overflow before adding the next digit.  
   - Update `result = result * 10 + digit`.  
5. Apply the sign and clamp the value if needed.  

### Pseudocode
~~~text
function myAtoi(s):
    INT_MAX = 2^31 - 1
    INT_MIN = -2^31
    index = 0
    result = 0
    sign = 1

    // 1. Skip leading spaces
    while index < length(s) and s[index] == ' ':
        index += 1

    // 2. Handle sign
    if index < length(s) and (s[index] == '+' or s[index] == '-'):
        sign = -1 if s[index] == '-' else 1
        index += 1

    // 3. Convert digits
    while index < length(s) and s[index] is a digit:
        digit = int(s[index])

        // 4. Check overflow
        if result > (INT_MAX - digit) // 10:
            return INT_MAX if sign == 1 else INT_MIN

        result = result * 10 + digit
        index += 1

    return result * sign
~~~

- Time Complexity: O(n) where n is the length of the string `s`.
- Space Complexity: O(1).

---

## Approach 2: Finite State Machine (FSM)

### Algorithm
1. Define states: `start`, `sign`, `number`, and `end`.  
2. Build a state transition table to control how characters affect the parsing.  
3. For each character, determine the next state and update variables accordingly.  
4. This structured approach helps when parsing complex inputs consistently.  

### Pseudocode
~~~text
function myAtoi(s):
    state = "start"
    sign = 1
    result = 0

    for char in s:
        if state == "start":
            if char == ' ': continue
            else if char == '+' or char == '-':
                sign = -1 if char == '-' else 1
                state = "sign"
            else if char is digit:
                result = int(char)
                state = "number"
            else:
                break

        else if state == "sign" or state == "number":
            if char is digit:
                digit = int(char)
                if result > (INT_MAX - digit) // 10:
                    return INT_MAX if sign == 1 else INT_MIN
                result = result * 10 + digit
                state = "number"
            else:
                break

    return result * sign
~~~

- Time Complexity: O(n) where n is the length of the string `s`.
- Space Complexity: O(1).

---

## Key Insight  

This problem tests your ability to handle **input sanitization, numeric conversion, and overflow** carefully — all essential for robust parsing in real-world applications.  

The **iterative parsing approach** is more intuitive for most developers, while the **state machine** version gives a cleaner structure for handling transitions and is closer to how real parsers work.
